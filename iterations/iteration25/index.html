<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Test</title>
    <script src="https://aframe.io/releases/1.0.4/aframe.min.js"></script>
</head>
<body>
<script>
    var tunnelRotation = 0;

    var renderDistance = 30;
    var movementSpeed = 0.05;

    var refreshRate = 1000;
    var nextUpdateTime = 0;

    var userLookAt = [0,0,0];
    var userRotationDeg = [0,0,0];

    var walls = [];
    var maxWalls = 24;
    var scene = null; //Initalised in wall-manager

    var color = getRandomColor();
    

    //https://stackoverflow.com/questions/1484506/random-color-generator
    function getRandomColor() {
        var letters = '0123456789ABCDEF';
        var color = '#';
        for (var i = 0; i < 6; i++) {
            color += letters[Math.floor(Math.random() * 16)];
        }
        return color;
    }

    function spawnSegment(x, y, z, rotX, rotY, rotZ){
        let newEntity = document.createElement('a-entity');
        let walls = [];

        //Square
        walls.push(spawnWall(-10, 0, 0, 0, 45, 0));
        walls.push(spawnWall(10, 0, 0, 0, -45, 0));
        walls.push(spawnWall(0, 10, 0, 45, 0, 0));
        walls.push(spawnWall(0, -10, 0, -45, 0, 0));

        //Square
        /*walls.push(spawnWall(-10, 0, 0, 0, 45, 0));
        walls.push(spawnWall(10, 0, 0, 0, -45, 0));
        walls.push(spawnWall(0, 10, 0, 45, 0, 0));
        walls.push(spawnWall(0, -10, 0, -45, 0, 0));*/
        
        for(w = 0; w < walls.length; w++){
            newEntity.appendChild(walls[w]);
        }

        newEntity.setAttribute('position', x+" "+y+" "+z);
        newEntity.setAttribute('rotation', rotX+" "+rotY+" "+rotZ+tunnelRotation);
        tunnelRotation += 10;
        /*newEntity.object3D.position.set(x, y, z);
        newEntity.object3D.rotation.set(rotX, rotY, rotZ);*/
        scene.appendChild(newEntity);
    }

    function spawnWall(x, y, z, rotX, rotY, rotZ){
        //console.log("Spawn Wall at "+x+", "+y+", "+z+"");
        let newWall = null;
        if(true /*walls.length <= maxWalls*/){
            newWall = document.createElement('a-plane');
            newWall.setAttribute('wall', '');
            newWall.setAttribute('height', '20');
            newWall.setAttribute('width', '20');
            newWall.setAttribute('position', x+" "+y+" "+z);
            newWall.setAttribute('rotation', rotX+" "+rotY+" "+rotZ);
            newWall.setAttribute('material', 'side: double');
            newWall.setAttribute('color', color);
            //newWall.setAttribute('color', "#00"+Math.round(Math.random()*29+60)+""+Math.round(Math.random()*29+60));
        }
        return newWall;
    }

    function despawnWall(wall){
        let index = walls.findIndex(otherWall => otherWall === wall);
        walls.splice(index, 1);
        wall.el.remove();
    }

    AFRAME.registerComponent("wall", {
        init: function(){
            walls.push(this);
        },
        
        refresh: function(){
            //Remove Walls that are out of renderDistance
            let thisPos = this.el.object3D.position;
            let camPos = rig.object3D.position;

            let thisV = [thisPos.x, thisPos.y, thisPos.z];
            let camV = [camPos.x, camPos.y, camPos.z];

            let distance = getMagnitude(subtractVectors(thisV, camV));

            /*if( distance < 10){
                despawnWall(this);
            }*/
        }
    });

    AFRAME.registerComponent("wall-manager", {
        init: function(){
            scene = document.getElementById("a-scene");
            scene.setAttribute('background', 'color: '+color);
            scene.setAttribute('fog', 'type: linear; color: '+color+'; near: 8; far: 12');
        },

        tick: function(){
            if(Date.now() >= nextUpdateTime){
                console.log("Refresh");
                let camPos = rig.object3D.position;
                let v = scalarTimesVector(0.2, getUnitVector(userLookAt));

                let spawnX = camPos.x-v[0]*renderDistance;
                let spawnY = camPos.y-v[1]*renderDistance;
                let spawnZ = camPos.z-v[2]*renderDistance;

                spawnSegment(spawnX, spawnY, spawnZ, userRotationDeg[1], userRotationDeg[0], userRotationDeg[2]);
                
                for(w = 0; w < walls.length; w++){
                    walls[w].el.components.wall.refresh();
                }
                
                while(walls.length > maxWalls){
                    despawnWall(walls[0]);
                }
                
                nextUpdateTime = Date.now() + refreshRate;
            }
        }
    });

    AFRAME.registerComponent("movement", {
        tick: function(){
            let rot = camera.object3D.rotation; //Rad

            let alpha = rot.y;
            let beta = rot.x;

            userRotationDeg = [alpha*180/Math.PI, beta*180/Math.PI, 0];

            //https://stackoverflow.com/questions/30011741/3d-vector-defined-by-2-angles
            let z = Math.cos(alpha) * Math.cos(beta);
            let x = Math.sin(alpha) * Math.cos(beta);
            let y = -Math.sin(beta);

            userLookAt = [x, y, z];

            let v = scalarTimesVector(movementSpeed, getUnitVector(userLookAt));
            let pos = this.el.object3D.position;
            this.el.object3D.position.set(pos.x - v[0], pos.y - v[1], pos.z - v[2]);
        }
    });
</script>

<a-scene id="a-scene" background="color: #003333" fog="type: linear; color: #003333; near: 8; far: 12">
    <!--a-sky color="#444444"></a-sky-->

    <a-entity wall-manager></a-entity>

    <a-entity id="rig" movement position="0 0 0">
        <a-entity id="camera" camera look-controls></a-entity>
    </a-entity>
</a-scene>

<script>
function getMagnitude(v){
    return Math.sqrt(Math.pow(v[0],2) + Math.pow(v[1],2) + Math.pow(v[2],2));
}

function getUnitVector(v){
	var mag = getMagnitude(v);

	return [v[0]/mag, v[1]/mag, v[2]/mag];
}

function scalarTimesVector(s, v){
	return [s*v[0], s*v[1], s*v[2]];
}

function addVectors(v1, v2){
	return [v1[0]+v2[0], v1[1]+v2[1], v1[2]+v2[2]];
}

function subtractVectors(v1, v2){
	return [v1[0]-v2[0], v1[1]-v2[1], v1[2]-v2[2]];
}
</script>
</body>
</html>